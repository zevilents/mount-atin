-- Executor-friendly: Path + visual waypoints + fallback manual walker
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local player = Players.LocalPlayer

-- === ganti kalau perlu ===
local POS2 = Vector3.new(-184, 128, 408)
local POS3 = Vector3.new(-166, 229, 652)
-- =========================

-- create GUI in CoreGui (some executors require CoreGui)
if CoreGui:FindFirstChild("AutoPathGui") then
	CoreGui.AutoPathGui:Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AutoPathGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = CoreGui

local btn = Instance.new("TextButton")
btn.Size = UDim2.new(0,220,0,44)
btn.Position = UDim2.new(0.5,-110,0.8,0)
btn.Text = "Jalan POS2 â†’ POS3 (Visual)"
btn.BackgroundColor3 = Color3.fromRGB(50,150,255)
btn.TextColor3 = Color3.new(1,1,1)
btn.Font = Enum.Font.SourceSansBold
btn.TextSize = 18
btn.Parent = screenGui

-- helper: visual waypoint parts
local visualParts = {}
local function clearVisuals()
	for _, p in ipairs(visualParts) do
		if p and p.Parent then p:Destroy() end
	end
	visualParts = {}
end

local function makeVisual(pos, color, size)
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Size = Vector3.new(size,size,size)
	part.Position = pos
	part.Material = Enum.Material.Neon
	part.Color = color
	part.Shape = Enum.PartType.Ball
	part.Parent = workspace
	table.insert(visualParts, part)
	return part
end

-- compute path (pcall-safe)
local function computePath(startPos, goal)
	local ok, path = pcall(function()
		local p = PathfindingService:CreatePath({
			AgentHeight = 5,
			AgentRadius = 2,
			AgentCanJump = true,
			AgentJumpHeight = 10,
			AgentMaxSlope = 45,
		})
		p:ComputeAsync(startPos, goal)
		return p
	end)
	if not ok then return nil end
	return path
end

-- wait for MoveToFinished with timeout + retry logic
local function moveToAndWait(humanoid, targetPos, timeout)
	timeout = timeout or 5
	local reached = false
	local conn
	conn = humanoid.MoveToFinished:Connect(function(r)
		reached = r
	end)
	humanoid:MoveTo(targetPos)
	local t0 = tick()
	while tick() - t0 < timeout and not reached do
		task.wait(0.08)
	end
	if conn then conn:Disconnect() end
	return reached
end

-- manual step fallback (small steps)
local function manualStepWalk(humanoid, hrp, goal)
	local stepSize = 8
	local tries = 0
	while (hrp.Position - goal).Magnitude > 5 and tries < 200 do
		local dir = (goal - hrp.Position)
		if dir.Magnitude < 1 then break end
		dir = dir.Unit
		local step = hrp.Position + dir * math.min(stepSize, (goal - hrp.Position).Magnitude)
		local reached = moveToAndWait(humanoid, step, 2.5)
		if not reached then
			-- coba lompat & ulang
			humanoid.Jump = true
			task.wait(0.15)
			reached = moveToAndWait(humanoid, step, 2)
		end
		tries = tries + 1
		task.wait(0.05)
	end
	return (hrp.Position - goal).Magnitude <= 6
end

-- main routine
local function runPathTo(posFrom, posTo)
	-- ensure character ready
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:FindFirstCh
